---
title: 'Randomization Inference in R: a better way to compute p-values in randomized experiments'
author: Francisco Yirá
date: '2022-01-18'
slug: randomization-inference-causal-mixtape
cover: "images/dices.jpg"
useRelativeCover: true
isMath: "true"
categories:
  - causal-inference
  - data-science
  - R
  - tutorial
tags:
  - causal-inference-the-mixtape
  - summaries
  - p-values
  - randomization-inference
  - books
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Welcome to a new post of <a href="https://www.franciscoyira.com/es/tags/causal-inference-the-mixtape/">the series</a> about the book <a href="https://mixtape.scunning.com/"><strong>Causal Inference: The Mixtape</strong></a>.
In the previous post, we saw an introduction to the <a href="/es/post/potential-outcomes-causal-inference-mixtape/">potential outcomes notation</a> and how this notation allows us to express key concepts in the causal inference field.</p>
<p>One of those key concepts is that the simple difference in outcomes (SDO) is an unbiased estimator of the average treatment effect whenever the treatment has been randomly assigned (i.e., in those cases correlation <em>is</em> causation).</p>
<p>However, unbiasedness (having an expected value equal to the average effect) is not the only relevant property of a causal estimator. We’re also interested in the <strong>variance</strong> because, in the real world, we observe just <em>individual realizations</em> of the data generating process, which may as well be far away from the expected value<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>To incorporate this dimension in our analyses, we have tools such as <strong>means tests, linear regression, and the ANOVA</strong>, which take into consideration both the difference in means and the estimated variance to tell us how sure can we be about the existence of a true difference between treated and control units (i.e., about each group coming from a different data generating process).</p>
<p>These methods are very popular and their use is widespread, but this doesn’t mean they’re always the best tool for doing causal inference on experimental data. Because of that, today we’re going to talk about an alternative methodology which, under some circumstances, can be a better option to carry out hypothesis tests on randomized experiments. Its name is <strong>Randomization Inference</strong>.</p>
<div id="why-bother" class="section level2">
<h2>Why bother?</h2>
<p>A question you may be asking yourself at this point is why it would be worth investing time in learning and applying this methodology when we already have the usual hypothesis tests that are widely known and used. I would be asking myself the same.</p>
<p><img src="images/but-why-should-i-care-01.jpg" width="300" /></p>
<p>The reasons to carry out hypothesis tests based on Randomization Inference (RI) can be summarised as follows:</p>
<ol style="list-style-type: decimal">
<li><p>When doing causal inference on experimental data, the main source of uncertainty is not the sampling from a bigger population but the random assignment of the treatment combined with the impossibility of knowing the counterfactual values. Standard hypotheses testing doesn’t take this into account and focuses on the sampling uncertainty instead. <strong>This is especially problematic if we work with large administrative datasets that literally represent “all the data”</strong> because it may lead to underestimating the total uncertainty in our figures. RI tackles this problem by considering the uncertainty that comes from the random assignment of the treatment, so it’s a better-suited methodology for these cases.</p></li>
<li><p>There are also advantages of using RI when we’re in the opposite situation: <strong>small data and/or very few treated units</strong>. In such cases, it doesn’t seem reasonable to rely on the “large samples” properties on which standard tests are based. Specifically, we may suffer from an increased vulnerability to outliers and high leverage observations, which translates to an increased risk of over-rejection of the null hypothesis. RI can help us in such situations because it’s a methodology <strong>more robust to outliers</strong>, especially when it is combined with ranking or quantile test statistics (which will be explained in detail later on).</p></li>
<li><p>Finally, even if there isn’t any particular problem with traditional hypothesis testing, RI gives us much more freedom regarding the statistics we can use. When using a standard hypothesis test, we’re restricted to statistics for which the variance can be estimated or the test has been constructed analytically. In contrast, RI allows us to use <strong>literally any scalar statistic that we can get from a dataset</strong> and it doesn’t even require us to assume a particular distribution function for its estimator. Some examples of useful statistics that we could use are quantile statistics (such as the median), ranking statistics, or the <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">KS statistic (Kolmogorov-Smirnov)</a> which measures differences the outcomes distributions.</p></li>
</ol>
<p>As a bonus, <strong>doing Randomization Inference is cool</strong>, in the sense that in the causal inference world there is an aesthetic preference for <strong>placebo methodologies</strong>, and RI can be considered as one of them. These methodologies are characterised by simulating fake treatments in real data and then checking that we <em>don’t</em> find relevant effects for those fake treatments, so we can be more confident that the conclusions about the true treatment are valid<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. Below we will see that RI does something very close to that.</p>
</div>
<div id="randomization-inference-step-by-step-in-r" class="section level2">
<h2>Randomization Inference step by step in R</h2>
<p>In order to explain the methodology itself, let’s remember first the goal and context on which we would apply this procedure. We’re analysing data coming from a randomized experiment and we have:</p>
<ul>
<li><p>A set of observations that were randomly assigned to treatment and control groups.</p></li>
<li><p>An outcome variable (<span class="math inline">\(Y\)</span>).</p></li>
</ul>
<p>And we want to figure out <strong>if the treatment has any real effect over that outcome variable</strong>.</p>
<p>As there will always be differences between treatment and control groups (just because of the random variability in the data generating process), we need to carry out some hypothesis test to verify if the observed differences between groups are big enough to be considered as evidence of a causal effect.</p>
<p>When in this situation, we can perform a <strong>Randomization Inference</strong> hypothesis test by applying the following steps:</p>
<div id="step-1-choose-a-sharp-null-hypothesis" class="section level3">
<h3>Step 1: choose a <em>sharp</em> null hypothesis</h3>
<p>In a standard hypothesis test, we have a null hypothesis that states something regarding a population parameter, for instance, <span class="math inline">\(\beta_1=0\)</span> where <span class="math inline">\(\beta_1\)</span> is the coefficient of the treatment variable <span class="math inline">\(D\)</span>. What this null hypothesis is saying is that the <em>average</em> effect of the treatment is zero, but it doesn’t say anything about the individual treatment effects for each unit (<span class="math inline">\(\delta_i\)</span>).</p>
<p>In contrast, when we do RI, we use a <strong>sharp null</strong>, that is, a null that says something about each one of the individual treatment effects (<span class="math inline">\(\delta_i\)</span>).</p>
<p>The most used and well-known sharp null is the <strong>Fischer’s sharp null</strong>:</p>
<p><span class="math display">\[
\delta_i=0
\]</span>
Which posits that the treatment has zero effect for each of the units in the sample.</p>
<p>For the sake of simplicity, on this post we will use Fischer’s sharp null, but note that we may as well use alternative sharp nulls such as <span class="math inline">\(\delta_i=1\)</span> or <span class="math inline">\(\delta_i=2\)</span>. We could even test sharp nulls in which different groups or units have different values of <span class="math inline">\(\delta_i\)</span>. All that is required is to have a null that states <em>something</em> about each <span class="math inline">\(\delta_i\)</span>, and not just about <span class="math inline">\(E[\delta_i]\)</span>.</p>
<p>Why would we want to use null hypotheses like these? Because it allows us to <strong>complete the missing potential outcomes values in our dataset</strong>.</p>
<p>The data we usually see in an experiment has this structure:</p>
<pre class="r language-r"><code>library(tidyverse)
library(magrittr)
library(causaldata)

ri &lt;- causaldata::ri %&gt;% 
  mutate(id_unit = row_number(),
         y0 = as.numeric(y0),
         y1 = as.numeric(y1))

ri</code></pre>
<pre class="language-r"><code>## # A tibble: 8 x 6
##   name       d     y    y0    y1 id_unit
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;
## 1 Andy       1    10    NA    10       1
## 2 Ben        1     5    NA     5       2
## 3 Chad       1    16    NA    16       3
## 4 Daniel     1     3    NA     3       4
## 5 Edith      0     5     5    NA       5
## 6 Frank      0     7     7    NA       6
## 7 George     0     8     8    NA       7
## 8 Hank       0    10    10    NA       8</code></pre>
<p>For each unit, we observe both <span class="math inline">\(D_i\)</span> and <span class="math inline">\(Y_i\)</span>, but just one of the potential outcomes (<span class="math inline">\(Y_i^0\)</span> or <span class="math inline">\(Y_i^1\)</span>). By leveraging the sharp null, we can fill in the missing values in the columns <code>y0</code> and <code>y1</code> (in this case, based on <span class="math inline">\(Y_i=Y_i^0=Y_i^1\)</span>).</p>
<pre class="r language-r"><code>ri_fischer_null &lt;- ri %&gt;% 
  mutate(y0 = y,
         y1 = y)

ri_fischer_null</code></pre>
<pre class="language-r"><code>## # A tibble: 8 x 6
##   name       d     y    y0    y1 id_unit
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;
## 1 Andy       1    10    10    10       1
## 2 Ben        1     5     5     5       2
## 3 Chad       1    16    16    16       3
## 4 Daniel     1     3     3     3       4
## 5 Edith      0     5     5     5       5
## 6 Frank      0     7     7     7       6
## 7 George     0     8     8     8       7
## 8 Hank       0    10    10    10       8</code></pre>
<p>Since we’re assuming that the treatment has an effect equal to zero for each unit, <strong>both potential outcomes are equal to the observed outcome</strong>.</p>
<p>Of course, we’re not claiming that this is really the case. We just want to discover how unlikely it is, under the sharp null assumption, to have observed the differences in means that we got in our experiment.</p>
</div>
<div id="step-2-pick-a-test-statistic" class="section level3">
<h3>Step 2: pick a test statistic</h3>
<p>To conduct a hypothesis test, we also need a <strong>statistic</strong>. In a standard hypothesis test, it would be necessary to use a statistic for which we had a variance estimator but, when doing RI, we can use literally any scalar statistic that can be obtained from a treatment assignments vector (<span class="math inline">\(D\)</span>) and an outcomes vector (<span class="math inline">\(Y\)</span>).</p>
<p>One of the simplest statistics we can use is the <strong>simple difference in mean outcomes (SDO)</strong> between groups.</p>
<pre class="r language-r"><code># Function that defines the statistic: it receives a dataframe as input,
# with the columns `y` (outcome) and `d` (treatment assignment), and returns
# a scalar value
sdo &lt;- function(data) {
  data %&gt;%
    summarise(te1 = mean(y[d == 1]),
              te0 = mean(y[d == 0]),
              sdo = te1 - te0) %&gt;%
    pull(sdo)
}

sdo(ri_fischer_null)</code></pre>
<pre class="language-r"><code>## [1] 1</code></pre>
<p>However, as I said before, there is no reason why we couldn’t use a different test statistic. This freedom is one of the main reasons for which we would want to do RI in the first place.</p>
<p>Some examples of alternative test statistics we could use are:</p>
<ul>
<li><p><strong>Quantile statistics</strong>, for example, the difference in <em>medians</em> (or any other percentile) between two groups. They’re particularly useful if we have problems with outliers or high leverage observations.</p></li>
<li><p><strong>Ranking statistics</strong>, which transform an outcome variable (<span class="math inline">\(Y\)</span>) into ranking values (1 for the lowest outcome, 2 for the second-lowest, and so on) and then compute a metric based on those rankings (for instance, the difference in mean or median ranking).</p></li>
<li><p><strong>KS statistic (Kolmogorov-Smirnov)</strong>, which detects differences between outcome <em>distributions</em> by measuring the maximum distance between the cumulative distribution functions. This statistic would allow us, for instance, to identify the effect of a treatment that changes the variance or dispersion of the outcome but not its mean.</p></li>
</ul>
<p>For simplicity’s sake (again), the SDO will be used as test statistic in this example but, afterwards, I will show another code example using the KS statistic.</p>
</div>
<div id="step-3-simulate-many-treatment-assignments-to-get-the-statistic-distribution" class="section level3">
<h3>Step 3: simulate many treatment assignments to get the statistic distribution</h3>
<p>The next step consists in getting the distribution of values that the test statistic may take under the sharp null.</p>
<p>For this:</p>
<ol style="list-style-type: decimal">
<li><p>We will do permutations over the vector <span class="math inline">\(D\)</span> using the same random process that was used for obtaining the random treatment assignments in the first place. For example, if the treatment was assigned by a process equivalent to tossing a coin for each unit (<a href="https://en.wikipedia.org/wiki/Binomial_distribution"><span class="math inline">\(B(n, 0.5)\)</span></a>), then the permutations must be generated in the same way.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<p>In our example, the random process consists in drafting 4 treatment assignments for a sample of 8 observations, which translates to 70 possible permutations in total. The following code obtains such permutations:</p>
<pre class="r language-r"><code>perms &lt;- t(combn(ri_fischer_null$id_unit, 4)) %&gt;% asplit(1) 

perms_df &lt;- 
  tibble(treated_units = perms) %&gt;% 
  transmute(id_perm = row_number(),
            treated_units = map(treated_units, unlist))

ri_permuted &lt;- 
  crossing(perms_df, ri_fischer_null) %&gt;% 
  mutate(d = map2_dbl(id_unit, treated_units, ~.x %in% .y))

ri_permuted</code></pre>
<pre class="language-r"><code>## # A tibble: 560 x 8
##    id_perm treated_units name       d     y    y0    y1 id_unit
##      &lt;int&gt; &lt;list&gt;        &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;
##  1       1 &lt;int [4]&gt;     Andy       1    10    10    10       1
##  2       1 &lt;int [4]&gt;     Ben        1     5     5     5       2
##  3       1 &lt;int [4]&gt;     Chad       1    16    16    16       3
##  4       1 &lt;int [4]&gt;     Daniel     1     3     3     3       4
##  5       1 &lt;int [4]&gt;     Edith      0     5     5     5       5
##  6       1 &lt;int [4]&gt;     Frank      0     7     7     7       6
##  7       1 &lt;int [4]&gt;     George     0     8     8     8       7
##  8       1 &lt;int [4]&gt;     Hank       0    10    10    10       8
##  9       2 &lt;int [4]&gt;     Andy       1    10    10    10       1
## 10       2 &lt;int [4]&gt;     Ben        1     5     5     5       2
## # ... with 550 more rows</code></pre>
<pre class="r language-r"><code>ri_permuted %&gt;% 
  pull(id_perm) %&gt;% 
  n_distinct()</code></pre>
<pre class="language-r"><code>## [1] 70</code></pre></li>
<li><p>For each permutation, we simulate the values of <span class="math inline">\(Y\)</span> based on the previously chosen sharp null and the now complete potential outcomes columns. <strong>For Fischer’s sharp null, we don’t have to do anything</strong> because it states that <span class="math inline">\(Y_i=Y_i^0=Y_i^1\)</span>, which leads to the vector <span class="math inline">\(Y\)</span> remaining unchanged no matter the values in <span class="math inline">\(D\)</span>. However, if our sharp null was something like <span class="math inline">\(\delta_i=1\)</span>, then it would be necessary to update/change the values of <span class="math inline">\(Y\)</span> in each permutation.</p></li>
<li><p>We compute the test statistic value (the SDO in our example) for each permutation and then save those values.</p>
<pre class="r language-r"><code>perms_stats &lt;- 
  ri_permuted %&gt;%
  group_by(id_perm) %&gt;%
  summarise(te1 = mean(y[d == 1]),
            te0 = mean(y[d == 0]),
            sdo = te1 - te0)

perms_stats %&gt;% 
  select(id_perm, sdo)</code></pre>
<pre class="language-r"><code>## # A tibble: 70 x 2
##    id_perm   sdo
##      &lt;int&gt; &lt;dbl&gt;
##  1       1   1  
##  2       2   2  
##  3       3   3  
##  4       4   3.5
##  5       5   4.5
##  6       6  -4.5
##  7       7  -3.5
##  8       8  -3  
##  9       9  -2  
## 10      10  -2.5
## # ... with 60 more rows</code></pre></li>
<li><p>Voilà! The statistic values obtained in (3) tell us what the statistic’s distribution is under the sharp null assumption.</p>
<pre class="r language-r"><code>ggplot(perms_stats, aes(sdo)) +
  geom_histogram() +
  labs(x = &quot;Test statistic (SDO)&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p></li>
</ol>
<p><strong>How many permutations should we do?</strong> Ideally, we should obtain all the possible permutations in order to get an exact representation of the test statistic distribution under the sharp null. However, this is only feasible in very small datasets: even with a dataset of 2000 rows, it becomes computationally prohibitive to get all the possible permutations of the treatment assignment.</p>
<p>The fall-back option, in this case, is to resign oneself to do enough permutations to get a reasonable approximation to the statistic’s distribution<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
</div>
<div id="step-4-obtaining-the-p-value-by-comparing-the-real-statistic-with-its-simulated-distribution" class="section level3">
<h3>Step 4: obtaining the p-value by comparing the “real” statistic with its simulated distribution</h3>
<p>After having obtained the statistic’s distribution (exact or approximated) under the sharp null, we can proceed to locate the true statistic (the one that comes from the real values of <span class="math inline">\(D\)</span> and <span class="math inline">\(Y\)</span>) inside that distribution.</p>
<p><em>Note that if we want to perform a two-tailed test (the most common one), we must apply the absolute value function to the statistic distribution (which is, in fact, what we do in this example).</em></p>
<pre class="r language-r"><code>true_statistic &lt;- perms_stats %&gt;% 
  filter(id_perm == 1) %&gt;% 
  pull(sdo)

ggplot(perms_stats, 
       # Applying `abs` because we want a two tailed test
       aes(abs(sdo))) +
  geom_histogram() +
  labs(x = &quot;Absolute value of the test statistic (SDO)&quot;,
       y = &quot;count&quot;) +
  geom_vline(xintercept = true_statistic, colour = &quot;red&quot;, size = 2) +
  annotate(geom = &quot;label&quot;,
           x = true_statistic,
           y = 10,
           label = &quot;&#39;True&#39; statistic&quot;,
           colour = &quot;red&quot;) +
  annotate(&quot;segment&quot;, x = true_statistic+1, xend = true_statistic+3, y = 9, yend =9,
           colour = &quot;purple&quot;, size = 2, arrow = arrow()) +
  annotate(geom = &quot;label&quot;,
           x = true_statistic+2,
           y = 10,
           label = &quot;More &#39;extreme&#39; statistics&quot;,
           colour = &quot;purple&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>Having done this, we can calculate the <strong>p-value</strong> itself (which is what we have been looking for since the beginning).</p>
<p>This p-value can be calculated through the following steps:</p>
<ol style="list-style-type: decimal">
<li>We create a <strong>descending ranking with the test statistics</strong> we obtained through the permutations (the highest value gets a ranking equal to 1, the lowest value gets a ranking equal to N). These rankings are assigned through a <code>row_number()</code>-like algorithm. When there are ties, the original ranking of the tied statistics is replaced with the maximum ranking inside that group. For instance, if three statistics have the same value and their original rankings are 2, 3 and 4, all of them end up with a ranking equal to 4.</li>
</ol>
<pre class="r language-r"><code>perms_ranked &lt;- perms_stats %&gt;%
  # Just like before, we apply `abs()` to get a two tailed test
  mutate(abs_sdo = abs(sdo)) %&gt;% 
  select(id_perm, abs_sdo) %&gt;% 
  arrange(desc(abs_sdo)) %&gt;% 
  mutate(rank = row_number(desc(abs_sdo))) %&gt;% 
  group_by(abs_sdo) %&gt;% 
  mutate(new_rank = max(rank))

perms_ranked</code></pre>
<pre class="language-r"><code>## # A tibble: 70 x 4
## # Groups:   abs_sdo [11]
##    id_perm abs_sdo  rank new_rank
##      &lt;int&gt;   &lt;dbl&gt; &lt;int&gt;    &lt;int&gt;
##  1      25     6       1        2
##  2      46     6       2        2
##  3      24     5.5     3        4
##  4      47     5.5     4        4
##  5       5     4.5     5       12
##  6       6     4.5     6       12
##  7      22     4.5     7       12
##  8      23     4.5     8       12
##  9      48     4.5     9       12
## 10      49     4.5    10       12
## # ... with 60 more rows</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>We calculate the ratio between the final ranking of the true statistic and N, the total number of permutations we did.</li>
</ol>
<pre class="r language-r"><code>n &lt;- nrow(perms_ranked)

p_value &lt;- 
  perms_ranked %&gt;% 
  filter(id_perm == 1) %&gt;%
  pull(new_rank)/n

p_value</code></pre>
<pre class="language-r"><code>## [1] 0.8571429</code></pre>
<p>In our example, the p-value we got is 0.86, which implies that we can’t reject the sharp null at a 5% significance level (in fact, we can’t reject it at any conventional significance level 😅). In other words, <strong>the SDO from the original data is not an unlikely value to observe if we assume that the treatment had zero effect on all the units</strong> and that the only source of variability in the statistic is the random assignment of <span class="math inline">\(D\)</span>.</p>
</div>
</div>
<div id="making-it-easier-with-the-ri2-package" class="section level2">
<h2>Making it easier with the <em>ri2</em> package 🤗</h2>
<p>The R code shown above had the goal of explaining each step of the RI procedure. However, it’s not very concise and adapting it for other datasets would be tiresome and error prone. For that reason, it’s recommended to perform RI using one of the R packages that have been designed and developed for that end, such as <code>ri2</code>.</p>
<pre class="r language-r"><code>library(ri2)</code></pre>
<p>However, something from the “manual” code that doesn’t change is that we still have to provide 1) a test statistic, 2) a sharp null hypothesis, and 3) a randomization procedure. And just like before, the randomization procedure passed to <code>ri2</code> must be the same as the one used for assigning the treatment in the first place.</p>
<p>The difference is that now we can pass these elements more in an easier and clearer way.</p>
<p>To declare the <strong>randomization procedure</strong> we use the function <code>ri2::declare_ra</code>. In this case (just like in the preceding example), we’re declaring the random assignment of 4 treatment units (<code>m = 4</code>) in a sample of 8 units (<code>N = 8</code>).</p>
<pre class="r language-r"><code>declaration &lt;- declare_ra(N = 8, m = 4)
declaration</code></pre>
<pre class="language-r"><code>## Random assignment procedure: Complete random assignment 
## Number of units: 8 
## Number of treatment arms: 2 
## The possible treatment categories are 0 and 1.
## The number of possible random assignments is 70.  
## The probabilities of assignment are constant across units: 
## prob_0 prob_1 
##    0.5    0.5</code></pre>
<p>The output is stored in an R object that later we can pass to the function <code>ri2::conduct_ri</code>, which is the function that performs the RI procedure itself.</p>
<p>To declare the <strong>test statistic</strong> we have two options.</p>
<p>The first is to use the <code>formula</code> argument in the <code>conduct_ri</code> function. If our test statistic is just the SDO, then the formula will be something like <code>y ~ d</code>, where <code>y</code> is the outcome variable and <code>d</code> is the treatment assignment variable.</p>
<p>Alternatively, we can specify the statistic through the argument <code>test_function</code> (also in the function <code>conduct_ri</code>), which admits any R function capable of receiving a dataframe and returning a scalar (i.e., the statistic value).</p>
<p>In our example we’re going to use this last method:</p>
<pre class="r language-r"><code># Declaring the `test_function`
sdo &lt;- function(data) {
  # it receives a dataframe
  data %&gt;% 
  summarise(te1 = mean(y[d == 1], na.rm=TRUE),
            te0 = mean(y[d == 0], na.rm=TRUE),
            sdo = te1 - te0) %&gt;% 
    # and returns a scalar
    pull(sdo)
}</code></pre>
<p>The <strong>sharp null hypothesis</strong> can be specified through the <code>sharp_hypothesis</code> argument in <code>conduct_ri</code>. The default value for this argument is 0, so if we’re going to use Fischer’s sharp null then we omit it in our code.</p>
<p>Last but not least, we have to indicate the names that the columns containing <span class="math inline">\(Y\)</span> and <span class="math inline">\(D\)</span> have in our data, using the <code>assignment</code> and <code>outcome</code> arguments, and we also have to pass the dataset itself through the argument <code>data</code>.</p>
<p>After specifying all those arguments, we can execute the function <code>conduct_ri</code> and then inspect the output with the <code>summary</code>.</p>
<pre class="r language-r"><code>ri2_out &lt;- conduct_ri(
  test_function = sdo,
  assignment = &quot;d&quot;,
  outcome = &quot;y&quot;,
  declaration = declaration,
  sharp_hypothesis = 0,
  data = ri
)

summary(ri2_out)</code></pre>
<pre class="language-r"><code>##                    term estimate two_tailed_p_value
## 1 Custom Test Statistic        1          0.8571429</code></pre>
<p>As we see, the p-value returned by <code>conduct_ri</code> is exactly the same as the one we got with the “manual” code from the previous section, but now the code is much simpler and easier to read 😊.</p>
<p>Another advantage of <code>conduct_ri</code> is that its output can be directly plotted by the function <code>plot()</code>.</p>
<pre class="r language-r"><code>plot(ri2_out)</code></pre>
<pre><code>## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please
## use `guide = &quot;none&quot;` instead.</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>This plot is even better than the one we created manually in the previous section because it automatically highlights the statistics that are as or more extreme than the real statistic. It also appropriately portrays two-tailed tests without having to transform the statistics to their absolute value ✨.</p>
<p>In addition, since the output of <code>plot(ri2_out)</code> is a ggplot2 object, we can customize it or transform it through the ggplot2 functions we already know. For example, we can apply a <code>ggthemes</code> theme to make it look like a Stata plot:</p>
<pre class="r language-r"><code>plot(ri2_out) +
  ggthemes::theme_stata()</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>If we want to manually inspect the simulations data, we can extract the dataframe <code>sims_df</code> from the output of <code>conduct_ri</code>. This dataframe will have as many rows as permutations of <span class="math inline">\(D\)</span> had been performed.</p>
<pre class="r language-r"><code>ri2_out[[&quot;sims_df&quot;]] %&gt;% head()</code></pre>
<pre class="language-r"><code>##   est_sim est_obs                  term
## 1    -1.0       1 Custom Test Statistic
## 2    -2.0       1 Custom Test Statistic
## 3    -3.0       1 Custom Test Statistic
## 4    -3.5       1 Custom Test Statistic
## 5    -4.5       1 Custom Test Statistic
## 6     4.5       1 Custom Test Statistic</code></pre>
<p>It’s worth noting that <code>conduct_ri</code> also has a <code>sims</code> argument that specifies the <strong>number of permutations</strong> that will be carried out in order to obtain the p-value. Its default value is 1000, but we may want to increase it to get a more precise estimate.</p>
<div id="bonus-using-the-ks-statistic-to-measure-differences-between-outcome-distributions" class="section level3">
<h3>Bonus: using the KS statistic to measure differences between outcome distributions</h3>
<p>One of the advantages of RI that were mentioned at the beginning of this post was the freedom to use alternative test statistics, having as only restriction to be scalar values obtained from <span class="math inline">\(D\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p>One of the most interesting “alternative” statistics (in my opinion) is the <strong>KS statistic</strong> (Kolmogorov-Smirnov), which measures the maximum distance between two empirical cumulative distribution functions (ECDFs). In this case, it measures the distance between the ECDF of the treated units <span class="math inline">\(\hat{F_T}\)</span> and the ECDF of the control units <span class="math inline">\(\hat{F_C}\)</span>:</p>
<p><span class="math display">\[
T_{KS}=\max|\hat{F_T}(Y_i) - \hat{F_C}(Y_i)|
\]</span></p>
<p>We can see a visual example in the following plot, where the KS statistic equals the length of the red dotted line.</p>
<div class="figure">
<img src="images/ks_example.png" alt="" />
<p class="caption"><em>Example of KS statistic with 2 cumulative distribution functions. Source: <a href="https://stats.stackexchange.com/questions/208517/kolmogorov-smirnov-test-vs-t-test">StackExchange</a></em></p>
</div>
<p><strong>Why would we use the KS statistic instead of something more familiar, like the difference in means?</strong></p>
<p>Because we could have a treatment that affects the outcome distribution without changing the mean significantly. For instance, it could change the variance or generate a bi-modal distribution (translation into a real-world example: a treatment that has a large positive effect for half of the sample and a large negative effect for the other half).</p>
<p>Here is an example from <a href="https://github.com/scunning1975/mixtape/blob/master/R/ks.R">the Mixtape</a> with simulated data:</p>
<pre class="r language-r"><code>tb &lt;- tibble(
  d = c(rep(0, 20), rep(1, 20)),
  y = c(0.22, -0.87, -2.39, -1.79, 0.37, -1.54, 
        1.28, -0.31, -0.74, 1.72, 
        0.38, -0.17, -0.62, -1.10, 0.30, 
        0.15, 2.30, 0.19, -0.50, -0.9,
        -5.13, -2.19, 2.43, -3.83, 0.5, 
        -3.25, 4.32, 1.63, 5.18, -0.43, 
        7.11, 4.87, -3.10, -5.81, 3.76, 
        6.31, 2.58, 0.07, 5.76, 3.50)
)

kdensity_d1 &lt;- tb %&gt;%
  filter(d == 1) %&gt;% 
  pull(y)
kdensity_d1 &lt;- density(kdensity_d1)

kdensity_d0 &lt;- tb %&gt;%
  filter(d == 0) %&gt;% 
  pull(y)
kdensity_d0 &lt;- density(kdensity_d0)

kdensity_d0 &lt;- tibble(x = kdensity_d0$x, y = kdensity_d0$y, d = 0)
kdensity_d1 &lt;- tibble(x = kdensity_d1$x, y = kdensity_d1$y, d = 1)

kdensity &lt;- full_join(kdensity_d1, kdensity_d0,
                      by = c(&quot;x&quot;, &quot;y&quot;, &quot;d&quot;))
kdensity$d &lt;- as_factor(kdensity$d)

ggplot(kdensity)+
  geom_point(size = 0.3, aes(x,y, color = d))+
  xlim(-7, 8)+
  scale_color_discrete(labels = c(&quot;Control&quot;, &quot;Treatment&quot;))</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>If we do RI with the data from above using the SDO as test statistic, we can’t reject the sharp null of having zero effect for all the units, despite having two evidently different outcome distributions.</p>
<pre class="r language-r"><code>set.seed(1989)

conduct_ri(
  test_function = sdo,
  assignment = &quot;d&quot;,
  outcome = &quot;y&quot;,
  declaration = declare_ra(N = 40, m = 20),
  sharp_hypothesis = 0,
  data = tb,
  sims = 10000
)</code></pre>
<pre class="language-r"><code>##                    term estimate two_tailed_p_value
## 1 Custom Test Statistic    1.415             0.1361</code></pre>
<p>Let’s see what happens if we use the KS statistic instead of the SDO:</p>
<pre class="r language-r"><code># Declaring the function that obtains the KS statistic from a dataframe
ks_statistic &lt;- function(data) {
  
  control &lt;- data[data$d == 0, ]$y
  treated &lt;- data[data$d == 1, ]$y
  
  cdf1 &lt;- ecdf(control) 
  cdf2 &lt;- ecdf(treated)
  
  minMax &lt;- seq(min(control, treated),
                max(control, treated),
                length.out=length(c(control, treated))) 
  
  x0 &lt;-
    minMax[which(abs(cdf1(minMax) - cdf2(minMax)) == max(abs(cdf1(minMax) - cdf2(minMax))))]
  
  y0 &lt;- cdf1(x0)
  y1 &lt;- cdf2(x0) 
  
  diff &lt;- unique(abs(y0 - y1))
  
  diff
  
}

# Obtaining the p-value through RI with the KS statistic
set.seed(1989)

ri_ks &lt;-
  conduct_ri(
    test_function = ks_statistic,
    assignment = &quot;d&quot;,
    outcome = &quot;y&quot;,
    declaration = declare_ra(N = 40, m = 20),
    sharp_hypothesis = 0,
    data = tb,
    sims = 10000
  )

ri_ks</code></pre>
<pre class="language-r"><code>##                    term estimate two_tailed_p_value
## 1 Custom Test Statistic     0.45             0.0227</code></pre>
<p>The KS statistic does allow us to reject the sharp null at a 5% significance level<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>.</p>
<p>In the following plot, we can visualise the KS statistic corresponding to the true treatment assignment, along with the empirical CDFs of the treatment and control groups.</p>
<pre class="r language-r"><code>tb2 &lt;- tb %&gt;%
group_by(d) %&gt;%
arrange(y) %&gt;%
mutate(rn = row_number()) %&gt;%
ungroup()


cdf1 &lt;- ecdf(tb2[tb2$d == 0, ]$y) 
cdf2 &lt;- ecdf(tb2[tb2$d == 1, ]$y) 

minMax &lt;- seq(min(tb2$y),
              max(tb2$y),
              length.out=length(tb2$y)) 

x0 &lt;- 
  minMax[which(abs(cdf1(minMax) - cdf2(minMax)) == max(abs(cdf1(minMax) - cdf2(minMax))) )] 

y0 &lt;- cdf1(x0) 
y1 &lt;- cdf2(x0) 

ggplot(tb2) +
  geom_step(aes(x=y, y=rn, color=factor(d)),
            size = 1.5, stat=&quot;ecdf&quot;) +
  labs(y = &quot;Density&quot;) +
  geom_segment(aes(x = x0[1], y = y0[1], xend = x0[1], yend = y1[1]),
               linetype = &quot;dashed&quot;, color = &quot;red&quot;, size = 1) +
  geom_point(aes(x = x0[1] , y= y0[1]), color=&quot;red&quot;, size=4) +
  geom_point(aes(x = x0[1] , y= y1[1]), color=&quot;red&quot;, size=4)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
</div>
<div id="considerations-and-additional-references" class="section level2">
<h2>Considerations and additional references 🔍📚</h2>
<p>To conclude, I would like to comment on some additional details and considerations regarding the RI methodology:</p>
<ul>
<li><p>In order to obtain <strong>confidence intervals</strong> with RI we can iterate over a range of possible values for the test statistic and use each of them as sharp null in each iteration. The confidence interval will include all those values for which the sharp null couldn’t be rejected.</p></li>
<li><p><em>The Mixtape</em> warns us that RI has some <strong>bias against small effects when it is used among Fischer’s sharp null</strong>. This is because only relatively large treatment effects will allow rejecting that null at conventional significance levels (small effects would be “swamped by the randomization process”). Therefore, if we expect the treatment effect to be small, we should either add covariates that explain the outcome variable (we can do that with the argument <code>formula</code> in <code>ri2::conduct_ri</code>) or just not use RI.</p></li>
<li><p>Another criticism regarding this methodology is that, according to <a href="http://www.stat.columbia.edu/~gelman/">Andrew Gelman from Columbia University</a>, the sharp null <a href="https://youtu.be/XUh8KsaWfJ4?t=546">represents an “uninteresting and academic hypothesis”</a> since the idea of a constant effect for all the units would be excessively restrictive. In answer to that, <a href="https://youtu.be/XUh8KsaWfJ4?t=807">Xinran Li from UIUC proposes</a> the idea of generalising the RI procedure by estimating quantiles of individual effects to get conclusions such as “X% of the units have a treatment effect equal or superior to Y”.</p></li>
<li><p>There is an alternative package <a href="http://grantmcdermott.com/ritest/index.html"><code>ritest</code></a> that also allows performing RI in R. It’s a port of a STATA command with the same name, so it could be interesting for those folks who are more familiar with STATA.</p></li>
</ul>
<p>Finally, I share with you a couple of <strong>references</strong> in case you wish to go deeper on this topic.</p>
<ul>
<li><p><a href="https://cran.r-project.org/web/packages/ri2/vignettes/ri2_vignette.html"><code>ri2</code>’s vignette</a> has examples of how to use its functions for doing RI with more complex experimental designs, such as multi-arm trials, when evaluating interactions between the treatment and covariates, or when using clustering or blocking by groups.</p></li>
<li><p><a href="https://www.mattblackwell.org/files/teaching/s05-fisher.pdf">This document by Matthew Blackwell</a> summarises very well the key concepts of RI, so it’s a good reference or review material for this topic (in fact, I used it for writing this post, along with <a href="https://www.mattblackwell.org/files/teaching/s05-fisher.pdf">chapter 4 of Causal Inference: The Mixtape</a>).</p></li>
<li><p><a href="https://www.cambridge.org/core/books/abs/causal-inference-for-statistics-social-and-biomedical-sciences/fishers-exact-pvalues-for-completely-randomized-experiments/23AF990D2EF9C90D0A424D555FACE578">Chapter 5 of <em>Causal Inference for Statistics, Social, and Biomedical Sciences</em></a> from Imbens and Rubin (2015) goes deeper into several RI topics, especially with regard to test statistics.</p></li>
</ul>
<p><em>Your feedback is welcome! You can send me comments about this article to my <a href="mailto:francisco.yira@outlook.com">email</a>.</em></p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For example, two coins have the same expected value when tossed, but if we toss each one 5 times, it’s very likely that the number of heads and tails returned by each one is going to be different, just because of the intrinsic variance of this data generating process.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Some causal inference methodologies that tend to leverage placebo tests are Discontinuous Regression and Difference-in-differences. Both will be covered in more detail in future blog posts.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>If the randomization was done using clustering or blocking by groups, then we should do the same when obtaining the permutations.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>As a reference, the function <code>ri2::conduct_ri</code>, which is one of the RI implementations existing in R, performs 1000 simulations/permutations by default.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Of course, it’s a bad idea to repeat the RI test many times using different statistics until finding one that rejects the null since that would qualify as <a href="https://en.wikipedia.org/wiki/Data_dredging">p-hacking</a>. The test statistic, I think, should be part of the experiment design.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
